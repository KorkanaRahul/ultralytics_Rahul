activation: nn.ReLU()

# yolov8_eca_bifpn.yaml 
nc: 1
depth_multiple: 0.33
width_multiple: 0.50

backbone:
  # [from, n, module, args]
  - [-1, 1, Conv,     [3,  32, 3, 2]]          # 0-P1/2
  - [-1, 1, DWConv,   [64, 3, 2]]              # 1-P2/4
  - [-1, 2, GhostC2f, [64, True]]              # 2
  - [-1, 1, ECA,      [64]]                    # 3
  - [-1, 1, DWConv,   [128, 3, 2]]             # 4-P3/8
  - [-1, 3, GhostC2f, [128, True]]             # 5
  - [-1, 1, ECA,      [128]]                   # 6
  - [-1, 1, DWConv,   [256, 3, 2]]             # 7-P4/16
  - [-1, 3, GhostC2f, [256, True]]             # 8
  - [-1, 1, ECA,      [256]]                   # 9
  - [-1, 1, DWConv,   [512, 3, 2]]             # 10-P5/32
  - [-1, 1, GhostC2f, [512, True]]             # 11
  - [-1, 1, ECA,      [512]]                   # 12
  - [-1, 1, SPPF,     [512, 5]]                # 13: output (P5)

# BiFPN-Lite neck
head:
  # Top-down fusion
  - [[13, 9], 1, WeightedAdd, [256]]           # 14: Fuse P5 & P4
  - [-1, 1, DWConv, [256, 3, 1]]               # 15
  - [-1, 1, ECA, [256]]                        # 16
  - [-1, 1, nn.Upsample, [None, 2, 'nearest']]    # 17: up -> P3 scale
  - [[-1, 6], 1, WeightedAdd, [128]]           # 18: Fuse with P3
  - [-1, 1, DWConv, [128, 3, 1]]               # 19
  - [-1, 1, ECA, [128]]                        # 20

  # Bottom-up fusion
  - [-1, 1, DWConv, [128, 3, 2]]               # 21: down -> P4
  - [[-1, 16], 1, WeightedAdd, [256]]          # 22: fuse with P4
  - [-1, 1, DWConv, [256, 3, 1]]               # 23
  - [-1, 1, ECA, [256]]                        # 24
  - [-1, 1, DWConv, [256, 3, 2]]               # 25: down -> P5
  - [[-1, 13], 1, WeightedAdd, [512]]          # 26: fuse with P5
  - [-1, 1, DWConv, [512, 3, 1]]               # 27
  - [-1, 1, ECA, [512]]                        # 28

  # Detection heads (3 scales)
  - [[20, 24, 28], 1, Detect, [nc]]